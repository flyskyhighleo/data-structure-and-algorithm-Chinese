# 概述

通常，链表的翻转用双指针来实现，链表的特殊结构是它具有递归的属性，因此翻转链表也可以用递归实现。本文探讨翻转单链表的5种类型。

1. 双指针翻转整个单链表
2. 递归翻转整个单链表
3. 翻转单链表前k个节点
4. 翻转单链表的某个区间
5. k个节点一组翻转单链表

# 迭代翻转整个链表

```jsx
ListNode reverse(ListNode head) {
    ListNode prev = null;
    ListNode cur = head;

    while (cur != null) {
        ListNode nextNode = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nextNode;
    }

    return prev;
}
```

# 递归翻转整个链表

单链表的特殊结构（无论从哪个节点起都具有相同结构）使得它非常适合递归。

首先，明确递归函数 **ListNode reverse(ListNode head)** 的含义：翻转一个单链表，并返回新的头节点。

n0 → n1 → n2 → n3 → n4 翻转后 n0 ← n1 ← n2 ← n3 ← n4，返回 n4

由于单链表每个节点具有相同的结构，当我们把递归翻转函数作用在下一个节点的时候，**reverse(head.next)**, n2 → n3 → n4 得到翻转，并且返回 n4。我们将返回的头节点计作 **newHead**。

```java
ListNode newHead = reverse(head.next);
```

那么原单链表就变成了 **n1 → reverse(n2 → n3 → n4)**, **reverse(head.next)** 返回新的头节点 **n4 。**

现在我们需要处理头节点 **head** 与已被翻转后的链表的关系。原来的头节点现在需要作为尾节点链接在已被翻转的链表上。同时，原头节点需要指向空节点。

**n1 → (n2 ← n3 ← n4),**  ******n1****** 作为尾节点链接在被翻转的链表上 **n1 ← n2 ← n3 ← n4 ← n5**

```java
head.next.next = head;
head.next = null;
```

最后返回新的头节点，**newHead**。

```java
ListNode reverse(ListNode head) {

    if (head == null || head.next == null) {
        return head;
    }

    ListNode newHead = reverse(head.next);
    head.next.next = head;
    head.next = null;

    return newHead;
}
```

递归结束条件：

1. 当节点为空时，直接返回。
2. 当只有一个节点时，直接返回。
